
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Jul 07 19:48:29 CEST 2016
//----------------------------------------------------

package rs.ac.bg.etf.si110350;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.LinkedList;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Thu Jul 07 19:48:29 CEST 2016
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\207\000\002\052\002\000\002\002\011\000\002\002" +
    "\004\000\002\041\003\000\002\022\004\000\002\022\004" +
    "\000\002\022\004\000\002\022\002\000\002\053\002\000" +
    "\002\023\007\000\002\023\005\000\002\024\007\000\002" +
    "\024\005\000\002\051\003\000\002\051\003\000\002\051" +
    "\003\000\002\051\003\000\002\054\002\000\002\003\006" +
    "\000\002\055\002\000\002\003\010\000\002\003\005\000" +
    "\002\027\003\000\002\027\002\000\002\016\005\000\002" +
    "\016\003\000\002\036\003\000\002\036\005\000\002\056" +
    "\002\000\002\025\011\000\002\057\002\000\002\017\006" +
    "\000\002\017\002\000\002\035\005\000\002\035\005\000" +
    "\002\035\003\000\002\026\004\000\002\026\002\000\002" +
    "\044\003\000\002\004\004\000\002\004\002\000\002\060" +
    "\002\000\002\061\002\000\002\005\015\000\002\062\002" +
    "\000\002\063\002\000\002\005\015\000\002\010\003\000" +
    "\002\010\003\000\002\010\002\000\002\006\005\000\002" +
    "\006\005\000\002\006\003\000\002\007\004\000\002\007" +
    "\006\000\002\013\004\000\002\013\002\000\002\014\003" +
    "\000\002\014\003\000\002\037\004\000\002\021\007\000" +
    "\002\021\007\000\002\021\011\000\002\021\006\000\002" +
    "\021\011\000\002\021\006\000\002\020\006\000\002\020" +
    "\005\000\002\020\005\000\002\020\007\000\002\020\006" +
    "\000\002\020\006\000\002\020\007\000\002\020\007\000" +
    "\002\020\006\000\002\020\011\000\002\020\011\000\002" +
    "\020\006\000\002\020\006\000\002\020\004\000\002\020" +
    "\005\000\002\020\004\000\002\020\007\000\002\020\005" +
    "\000\002\020\007\000\002\020\007\000\002\020\011\000" +
    "\002\020\005\000\002\020\007\000\002\020\005\000\002" +
    "\011\003\000\002\011\002\000\002\012\005\000\002\012" +
    "\003\000\002\030\005\000\002\030\003\000\002\031\005" +
    "\000\002\031\003\000\002\032\003\000\002\032\005\000" +
    "\002\046\004\000\002\046\003\000\002\047\005\000\002" +
    "\047\003\000\002\045\005\000\002\045\003\000\002\050" +
    "\005\000\002\050\006\000\002\050\003\000\002\050\003" +
    "\000\002\050\003\000\002\050\003\000\002\050\003\000" +
    "\002\050\004\000\002\050\007\000\002\050\005\000\002" +
    "\042\003\000\002\043\005\000\002\064\002\000\002\043" +
    "\007\000\002\043\006\000\002\043\003\000\002\040\004" +
    "\000\002\040\003\000\002\033\003\000\002\033\003\000" +
    "\002\033\003\000\002\033\003\000\002\033\003\000\002" +
    "\033\003\000\002\015\003\000\002\015\003\000\002\034" +
    "\003\000\002\034\003\000\002\034\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\004\004\005\001\002\000\004\002\375\001" +
    "\002\000\004\022\006\001\002\000\012\006\ufffe\014\ufffe" +
    "\022\ufffe\055\ufffe\001\002\000\012\006\ufffa\014\ufffa\022" +
    "\ufffa\055\ufffa\001\002\000\012\006\017\014\011\022\020" +
    "\055\001\001\002\000\006\003\355\022\020\001\002\000" +
    "\012\006\ufffd\014\ufffd\022\ufffd\055\ufffd\001\002\000\012" +
    "\006\ufffc\014\ufffc\022\ufffc\055\ufffc\001\002\000\010\003" +
    "\335\022\ufff0\053\uffee\001\002\000\012\006\ufffb\014\ufffb" +
    "\022\ufffb\055\ufffb\001\002\000\004\055\330\001\002\000" +
    "\004\022\021\001\002\000\052\003\uffdb\022\uffdb\026\uffdb" +
    "\027\uffdb\030\uffdb\031\uffdb\032\uffdb\033\uffdb\034\uffdb\035" +
    "\uffdb\036\uffdb\037\uffdb\040\uffdb\041\uffdb\042\uffdb\046\uffdb" +
    "\047\uffdb\052\uffdb\053\uffdb\054\uffdb\001\002\000\006\020" +
    "\022\055\024\001\002\000\006\003\324\022\325\001\002" +
    "\000\010\022\uffe5\055\uffe5\056\uffe5\001\002\000\010\022" +
    "\uffde\055\uffde\056\uffde\001\002\000\010\022\uffdc\055\uffdc" +
    "\056\uffdc\001\002\000\010\022\020\055\031\056\uffe1\001" +
    "\002\000\004\056\323\001\002\000\010\022\uffdd\055\uffdd" +
    "\056\uffdd\001\002\000\010\016\uffe3\022\uffe3\056\uffe3\001" +
    "\002\000\010\016\uffd9\022\uffd9\056\uffd9\001\002\000\010" +
    "\016\037\022\020\056\034\001\002\000\004\056\uffe2\001" +
    "\002\000\004\022\311\001\002\000\010\016\uffda\022\uffda" +
    "\056\uffda\001\002\000\004\022\040\001\002\000\004\051" +
    "\uffd5\001\002\000\004\051\042\001\002\000\010\003\044" +
    "\022\020\052\uffd0\001\002\000\004\022\306\001\002\000" +
    "\006\047\304\052\uffd1\001\002\000\006\047\302\052\uffd2" +
    "\001\002\000\004\052\050\001\002\000\006\047\uffcd\052" +
    "\uffcd\001\002\000\006\022\uffdc\055\uffdc\001\002\000\006" +
    "\022\020\055\052\001\002\000\024\005\uffd4\007\uffd4\012" +
    "\uffd4\013\uffd4\015\uffd4\017\uffd4\022\uffd4\055\uffd4\056\uffd4" +
    "\001\002\000\024\005\uffc9\007\uffc9\012\uffc9\013\uffc9\015" +
    "\uffc9\017\uffc9\022\uffc9\055\uffc9\056\uffc9\001\002\000\024" +
    "\005\073\007\065\012\067\013\071\015\055\017\056\022" +
    "\057\055\060\056\072\001\002\000\006\003\271\051\272" +
    "\001\002\000\004\051\270\001\002\000\060\026\uff88\027" +
    "\uff88\030\uff88\031\uff88\032\uff88\033\uff88\034\uff88\035\uff88" +
    "\036\uff88\037\uff88\040\uff88\041\uff88\042\uff88\043\uff88\044" +
    "\uff88\045\uff88\046\uff88\047\uff88\050\uff88\051\uff88\052\uff88" +
    "\053\uff88\054\uff88\001\002\000\024\005\uffc9\007\uffc9\012" +
    "\uffc9\013\uffc9\015\uffc9\017\uffc9\022\uffc9\055\uffc9\056\uffc9" +
    "\001\002\000\024\005\uffc7\007\uffc7\012\uffc7\013\uffc7\015" +
    "\uffc7\017\uffc7\022\uffc7\055\uffc7\056\uffc7\001\002\000\014" +
    "\030\240\043\237\044\235\045\242\051\236\001\002\000" +
    "\024\003\225\011\077\021\102\022\057\023\107\024\104" +
    "\025\103\027\075\051\111\001\002\000\060\026\uff8d\027" +
    "\uff8d\030\uff8d\031\uff8d\032\uff8d\033\uff8d\034\uff8d\035\uff8d" +
    "\036\uff8d\037\uff8d\040\uff8d\041\uff8d\042\uff8d\043\uff8d\044" +
    "\uff8d\045\uff8d\046\uff8d\047\uff8d\050\216\051\uff8d\052\uff8d" +
    "\053\215\054\uff8d\001\002\000\004\051\157\001\002\000" +
    "\024\005\uffca\007\uffca\012\uffca\013\uffca\015\uffca\017\uffca" +
    "\022\uffca\055\uffca\056\uffca\001\002\000\006\003\142\051" +
    "\143\001\002\000\024\005\uffc8\007\uffc8\012\uffc8\013\uffc8" +
    "\015\uffc8\017\uffc8\022\uffc8\055\uffc8\056\uffc8\001\002\000" +
    "\024\011\077\021\102\022\057\023\107\024\104\025\103" +
    "\027\075\046\105\051\111\001\002\000\010\016\uffd3\022" +
    "\uffd3\056\uffd3\001\002\000\004\046\074\001\002\000\026" +
    "\005\uffb2\007\uffb2\010\uffb2\012\uffb2\013\uffb2\015\uffb2\017" +
    "\uffb2\022\uffb2\055\uffb2\056\uffb2\001\002\000\020\011\077" +
    "\021\102\022\057\023\107\024\104\025\103\051\111\001" +
    "\002\000\004\046\140\001\002\000\004\022\020\001\002" +
    "\000\046\026\uff95\027\uff95\030\uff95\031\uff95\032\uff95\033" +
    "\uff95\034\uff95\035\uff95\036\uff95\037\uff95\040\uff95\041\uff95" +
    "\042\uff95\046\uff95\047\uff95\051\125\052\uff95\054\uff95\001" +
    "\002\000\036\026\121\027\122\033\uff9c\034\uff9c\035\uff9c" +
    "\036\uff9c\037\uff9c\040\uff9c\041\uff9c\042\uff9c\046\uff9c\047" +
    "\uff9c\052\uff9c\054\uff9c\001\002\000\044\026\uff94\027\uff94" +
    "\030\uff94\031\uff94\032\uff94\033\uff94\034\uff94\035\uff94\036" +
    "\uff94\037\uff94\040\uff94\041\uff94\042\uff94\046\uff94\047\uff94" +
    "\052\uff94\054\uff94\001\002\000\044\026\uff92\027\uff92\030" +
    "\uff92\031\uff92\032\uff92\033\uff92\034\uff92\035\uff92\036\uff92" +
    "\037\uff92\040\uff92\041\uff92\042\uff92\046\uff92\047\uff92\052" +
    "\uff92\054\uff92\001\002\000\044\026\uff91\027\uff91\030\uff91" +
    "\031\uff91\032\uff91\033\uff91\034\uff91\035\uff91\036\uff91\037" +
    "\uff91\040\uff91\041\uff91\042\uff91\046\uff91\047\uff91\052\uff91" +
    "\054\uff91\001\002\000\026\005\uffb0\007\uffb0\010\uffb0\012" +
    "\uffb0\013\uffb0\015\uffb0\017\uffb0\022\uffb0\055\uffb0\056\uffb0" +
    "\001\002\000\044\026\uff9a\027\uff9a\030\115\031\116\032" +
    "\114\033\uff9a\034\uff9a\035\uff9a\036\uff9a\037\uff9a\040\uff9a" +
    "\041\uff9a\042\uff9a\046\uff9a\047\uff9a\052\uff9a\054\uff9a\001" +
    "\002\000\044\026\uff93\027\uff93\030\uff93\031\uff93\032\uff93" +
    "\033\uff93\034\uff93\035\uff93\036\uff93\037\uff93\040\uff93\041" +
    "\uff93\042\uff93\046\uff93\047\uff93\052\uff93\054\uff93\001\002" +
    "\000\044\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033" +
    "\uff98\034\uff98\035\uff98\036\uff98\037\uff98\040\uff98\041\uff98" +
    "\042\uff98\046\uff98\047\uff98\052\uff98\054\uff98\001\002\000" +
    "\022\011\077\021\102\022\057\023\107\024\104\025\103" +
    "\027\075\051\111\001\002\000\004\052\113\001\002\000" +
    "\044\026\uff8e\027\uff8e\030\uff8e\031\uff8e\032\uff8e\033\uff8e" +
    "\034\uff8e\035\uff8e\036\uff8e\037\uff8e\040\uff8e\041\uff8e\042" +
    "\uff8e\046\uff8e\047\uff8e\052\uff8e\054\uff8e\001\002\000\020" +
    "\011\uff7b\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025\uff7b\051" +
    "\uff7b\001\002\000\020\011\uff7d\021\uff7d\022\uff7d\023\uff7d" +
    "\024\uff7d\025\uff7d\051\uff7d\001\002\000\020\011\uff7c\021" +
    "\uff7c\022\uff7c\023\uff7c\024\uff7c\025\uff7c\051\uff7c\001\002" +
    "\000\020\011\077\021\102\022\057\023\107\024\104\025" +
    "\103\051\111\001\002\000\044\026\uff99\027\uff99\030\uff99" +
    "\031\uff99\032\uff99\033\uff99\034\uff99\035\uff99\036\uff99\037" +
    "\uff99\040\uff99\041\uff99\042\uff99\046\uff99\047\uff99\052\uff99" +
    "\054\uff99\001\002\000\020\011\uff7f\021\uff7f\022\uff7f\023" +
    "\uff7f\024\uff7f\025\uff7f\051\uff7f\001\002\000\020\011\uff7e" +
    "\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e\051\uff7e\001" +
    "\002\000\020\011\077\021\102\022\057\023\107\024\104" +
    "\025\103\051\111\001\002\000\044\026\uff9b\027\uff9b\030" +
    "\115\031\116\032\114\033\uff9b\034\uff9b\035\uff9b\036\uff9b" +
    "\037\uff9b\040\uff9b\041\uff9b\042\uff9b\046\uff9b\047\uff9b\052" +
    "\uff9b\054\uff9b\001\002\000\024\011\077\021\102\022\057" +
    "\023\107\024\104\025\103\027\075\051\111\052\127\001" +
    "\002\000\006\047\uffa4\052\uffa4\001\002\000\044\026\uff97" +
    "\027\uff97\030\uff97\031\uff97\032\uff97\033\uff97\034\uff97\035" +
    "\uff97\036\uff97\037\uff97\040\uff97\041\uff97\042\uff97\046\uff97" +
    "\047\uff97\052\uff97\054\uff97\001\002\000\006\047\131\052" +
    "\132\001\002\000\022\011\077\021\102\022\057\023\107" +
    "\024\104\025\103\027\075\051\111\001\002\000\044\026" +
    "\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033\uff96\034\uff96" +
    "\035\uff96\036\uff96\037\uff96\040\uff96\041\uff96\042\uff96\046" +
    "\uff96\047\uff96\052\uff96\054\uff96\001\002\000\006\047\uffa5" +
    "\052\uffa5\001\002\000\046\026\uff90\027\uff90\030\uff90\031" +
    "\uff90\032\uff90\033\uff90\034\uff90\035\uff90\036\uff90\037\uff90" +
    "\040\uff90\041\uff90\042\uff90\046\uff90\047\uff90\052\uff90\053" +
    "\135\054\uff90\001\002\000\022\011\077\021\102\022\057" +
    "\023\107\024\104\025\103\027\075\051\111\001\002\000" +
    "\004\054\137\001\002\000\044\026\uff8f\027\uff8f\030\uff8f" +
    "\031\uff8f\032\uff8f\033\uff8f\034\uff8f\035\uff8f\036\uff8f\037" +
    "\uff8f\040\uff8f\041\uff8f\042\uff8f\046\uff8f\047\uff8f\052\uff8f" +
    "\054\uff8f\001\002\000\026\005\uffb1\007\uffb1\010\uffb1\012" +
    "\uffb1\013\uffb1\015\uffb1\017\uffb1\022\uffb1\055\uffb1\056\uffb1" +
    "\001\002\000\036\026\121\027\122\033\uff9d\034\uff9d\035" +
    "\uff9d\036\uff9d\037\uff9d\040\uff9d\041\uff9d\042\uff9d\046\uff9d" +
    "\047\uff9d\052\uff9d\054\uff9d\001\002\000\004\046\156\001" +
    "\002\000\024\003\145\011\077\021\102\022\057\023\107" +
    "\024\104\025\103\027\075\051\111\001\002\000\006\047" +
    "\150\052\151\001\002\000\004\052\146\001\002\000\004" +
    "\046\147\001\002\000\026\005\uffa9\007\uffa9\010\uffa9\012" +
    "\uffa9\013\uffa9\015\uffa9\017\uffa9\022\uffa9\055\uffa9\056\uffa9" +
    "\001\002\000\004\021\153\001\002\000\004\046\152\001" +
    "\002\000\026\005\uffac\007\uffac\010\uffac\012\uffac\013\uffac" +
    "\015\uffac\017\uffac\022\uffac\055\uffac\056\uffac\001\002\000" +
    "\004\052\154\001\002\000\004\046\155\001\002\000\026" +
    "\005\uffab\007\uffab\010\uffab\012\uffab\013\uffab\015\uffab\017" +
    "\uffab\022\uffab\055\uffab\056\uffab\001\002\000\026\005\uffaa" +
    "\007\uffaa\010\uffaa\012\uffaa\013\uffaa\015\uffaa\017\uffaa\022" +
    "\uffaa\055\uffaa\056\uffaa\001\002\000\024\003\162\011\077" +
    "\021\102\022\057\023\107\024\104\025\103\027\075\051" +
    "\111\001\002\000\010\041\uffa0\042\uffa0\052\uffa0\001\002" +
    "\000\024\033\211\034\210\035\207\036\206\037\205\040" +
    "\213\041\uff9f\042\uff9f\052\uff9f\001\002\000\004\052\177" +
    "\001\002\000\010\041\170\042\uffa2\052\uffa2\001\002\000" +
    "\006\042\166\052\165\001\002\000\022\005\073\007\065" +
    "\012\067\013\071\015\055\017\056\022\057\055\060\001" +
    "\002\000\022\011\077\021\102\022\057\023\107\024\104" +
    "\025\103\027\075\051\111\001\002\000\010\041\170\042" +
    "\uffa3\052\uffa3\001\002\000\022\011\077\021\102\022\057" +
    "\023\107\024\104\025\103\027\075\051\111\001\002\000" +
    "\010\041\uffa1\042\uffa1\052\uffa1\001\002\000\024\005\uffc5" +
    "\007\uffc5\012\uffc5\013\uffc5\015\uffc5\017\uffc5\022\uffc5\055" +
    "\uffc5\056\uffc5\001\002\000\026\005\uffc8\007\uffc8\010\174" +
    "\012\uffc8\013\uffc8\015\uffc8\017\uffc8\022\uffc8\055\uffc8\056" +
    "\uffc8\001\002\000\022\005\073\007\065\012\067\013\071" +
    "\015\055\017\056\022\057\055\060\001\002\000\024\005" +
    "\uffc1\007\uffc1\012\uffc1\013\uffc1\015\uffc1\017\uffc1\022\uffc1" +
    "\055\uffc1\056\uffc1\001\002\000\026\005\uffb6\007\uffb6\010" +
    "\uffb6\012\uffb6\013\uffb6\015\uffb6\017\uffb6\022\uffb6\055\uffb6" +
    "\056\uffb6\001\002\000\022\005\073\007\065\012\067\013" +
    "\071\015\055\017\056\022\057\055\060\001\002\000\024" +
    "\005\uffc4\007\uffc4\012\uffc4\013\uffc4\015\uffc4\017\uffc4\022" +
    "\uffc4\055\uffc4\056\uffc4\001\002\000\026\005\uffc8\007\uffc8" +
    "\010\202\012\uffc8\013\uffc8\015\uffc8\017\uffc8\022\uffc8\055" +
    "\uffc8\056\uffc8\001\002\000\022\005\073\007\065\012\067" +
    "\013\071\015\055\017\056\022\057\055\060\001\002\000" +
    "\024\005\uffc3\007\uffc3\012\uffc3\013\uffc3\015\uffc3\017\uffc3" +
    "\022\uffc3\055\uffc3\056\uffc3\001\002\000\026\005\uffb5\007" +
    "\uffb5\010\uffb5\012\uffb5\013\uffb5\015\uffb5\017\uffb5\022\uffb5" +
    "\055\uffb5\056\uffb5\001\002\000\022\011\uff81\021\uff81\022" +
    "\uff81\023\uff81\024\uff81\025\uff81\027\uff81\051\uff81\001\002" +
    "\000\022\011\uff82\021\uff82\022\uff82\023\uff82\024\uff82\025" +
    "\uff82\027\uff82\051\uff82\001\002\000\022\011\uff83\021\uff83" +
    "\022\uff83\023\uff83\024\uff83\025\uff83\027\uff83\051\uff83\001" +
    "\002\000\022\011\uff84\021\uff84\022\uff84\023\uff84\024\uff84" +
    "\025\uff84\027\uff84\051\uff84\001\002\000\022\011\uff85\021" +
    "\uff85\022\uff85\023\uff85\024\uff85\025\uff85\027\uff85\051\uff85" +
    "\001\002\000\022\011\077\021\102\022\057\023\107\024" +
    "\104\025\103\027\075\051\111\001\002\000\022\011\uff80" +
    "\021\uff80\022\uff80\023\uff80\024\uff80\025\uff80\027\uff80\051" +
    "\uff80\001\002\000\010\041\uff9e\042\uff9e\052\uff9e\001\002" +
    "\000\024\003\221\011\uff8b\021\uff8b\022\uff8b\023\uff8b\024" +
    "\uff8b\025\uff8b\027\uff8b\051\uff8b\001\002\000\004\022\217" +
    "\001\002\000\060\026\uff8c\027\uff8c\030\uff8c\031\uff8c\032" +
    "\uff8c\033\uff8c\034\uff8c\035\uff8c\036\uff8c\037\uff8c\040\uff8c" +
    "\041\uff8c\042\uff8c\043\uff8c\044\uff8c\045\uff8c\046\uff8c\047" +
    "\uff8c\050\uff8c\051\uff8c\052\uff8c\053\uff8c\054\uff8c\001\002" +
    "\000\022\011\077\021\102\022\057\023\107\024\104\025" +
    "\103\027\075\051\111\001\002\000\004\054\222\001\002" +
    "\000\060\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89\033" +
    "\uff89\034\uff89\035\uff89\036\uff89\037\uff89\040\uff89\041\uff89" +
    "\042\uff89\043\uff89\044\uff89\045\uff89\046\uff89\047\uff89\050" +
    "\uff89\051\uff89\052\uff89\053\uff89\054\uff89\001\002\000\004" +
    "\054\224\001\002\000\060\026\uff8a\027\uff8a\030\uff8a\031" +
    "\uff8a\032\uff8a\033\uff8a\034\uff8a\035\uff8a\036\uff8a\037\uff8a" +
    "\040\uff8a\041\uff8a\042\uff8a\043\uff8a\044\uff8a\045\uff8a\046" +
    "\uff8a\047\uff8a\050\uff8a\051\uff8a\052\uff8a\053\uff8a\054\uff8a" +
    "\001\002\000\004\052\232\001\002\000\006\042\166\052" +
    "\227\001\002\000\022\005\073\007\065\012\067\013\071" +
    "\015\055\017\056\022\057\055\060\001\002\000\024\005" +
    "\uffc0\007\uffc0\012\uffc0\013\uffc0\015\uffc0\017\uffc0\022\uffc0" +
    "\055\uffc0\056\uffc0\001\002\000\026\005\uffb4\007\uffb4\010" +
    "\uffb4\012\uffb4\013\uffb4\015\uffb4\017\uffb4\022\uffb4\055\uffb4" +
    "\056\uffb4\001\002\000\022\005\073\007\065\012\067\013" +
    "\071\015\055\017\056\022\057\055\060\001\002\000\024" +
    "\005\uffc2\007\uffc2\012\uffc2\013\uffc2\015\uffc2\017\uffc2\022" +
    "\uffc2\055\uffc2\056\uffc2\001\002\000\026\005\uffb3\007\uffb3" +
    "\010\uffb3\012\uffb3\013\uffb3\015\uffb3\017\uffb3\022\uffb3\055" +
    "\uffb3\056\uffb3\001\002\000\004\046\265\001\002\000\026" +
    "\003\256\011\077\021\102\022\057\023\107\024\104\025" +
    "\103\027\075\051\111\052\uffa6\001\002\000\024\003\250" +
    "\011\077\021\102\022\057\023\107\024\104\025\103\027" +
    "\075\051\111\001\002\000\006\022\uff86\030\uff86\001\002" +
    "\000\006\022\057\030\244\001\002\000\004\046\243\001" +
    "\002\000\026\005\uffbd\007\uffbd\010\uffbd\012\uffbd\013\uffbd" +
    "\015\uffbd\017\uffbd\022\uffbd\055\uffbd\056\uffbd\001\002\000" +
    "\006\022\uff87\030\uff87\001\002\000\004\046\246\001\002" +
    "\000\026\005\uffbf\007\uffbf\010\uffbf\012\uffbf\013\uffbf\015" +
    "\uffbf\017\uffbf\022\uffbf\055\uffbf\056\uffbf\001\002\000\004" +
    "\046\254\001\002\000\006\046\252\052\251\001\002\000" +
    "\004\046\253\001\002\000\026\005\uffba\007\uffba\010\uffba" +
    "\012\uffba\013\uffba\015\uffba\017\uffba\022\uffba\055\uffba\056" +
    "\uffba\001\002\000\026\005\uffb8\007\uffb8\010\uffb8\012\uffb8" +
    "\013\uffb8\015\uffb8\017\uffb8\022\uffb8\055\uffb8\056\uffb8\001" +
    "\002\000\026\005\uffb7\007\uffb7\010\uffb7\012\uffb7\013\uffb7" +
    "\015\uffb7\017\uffb7\022\uffb7\055\uffb7\056\uffb7\001\002\000" +
    "\004\052\263\001\002\000\006\046\261\052\260\001\002" +
    "\000\006\047\131\052\uffa7\001\002\000\004\046\262\001" +
    "\002\000\026\005\uffbb\007\uffbb\010\uffbb\012\uffbb\013\uffbb" +
    "\015\uffbb\017\uffbb\022\uffbb\055\uffbb\056\uffbb\001\002\000" +
    "\026\005\uffb9\007\uffb9\010\uffb9\012\uffb9\013\uffb9\015\uffb9" +
    "\017\uffb9\022\uffb9\055\uffb9\056\uffb9\001\002\000\004\046" +
    "\264\001\002\000\026\005\uffbc\007\uffbc\010\uffbc\012\uffbc" +
    "\013\uffbc\015\uffbc\017\uffbc\022\uffbc\055\uffbc\056\uffbc\001" +
    "\002\000\026\005\uffbe\007\uffbe\010\uffbe\012\uffbe\013\uffbe" +
    "\015\uffbe\017\uffbe\022\uffbe\055\uffbe\056\uffbe\001\002\000" +
    "\024\005\073\007\065\012\067\013\071\015\055\017\056" +
    "\022\057\055\060\056\267\001\002\000\026\005\uffa8\007" +
    "\uffa8\010\uffa8\012\uffa8\013\uffa8\015\uffa8\017\uffa8\022\uffa8" +
    "\055\uffa8\056\uffa8\001\002\000\024\003\uffc6\011\uffc6\021" +
    "\uffc6\022\uffc6\023\uffc6\024\uffc6\025\uffc6\027\uffc6\051\uffc6" +
    "\001\002\000\004\046\301\001\002\000\006\003\273\022" +
    "\057\001\002\000\004\052\277\001\002\000\004\052\275" +
    "\001\002\000\004\046\276\001\002\000\026\005\uffaf\007" +
    "\uffaf\010\uffaf\012\uffaf\013\uffaf\015\uffaf\017\uffaf\022\uffaf" +
    "\055\uffaf\056\uffaf\001\002\000\004\046\300\001\002\000" +
    "\026\005\uffad\007\uffad\010\uffad\012\uffad\013\uffad\015\uffad" +
    "\017\uffad\022\uffad\055\uffad\056\uffad\001\002\000\026\005" +
    "\uffae\007\uffae\010\uffae\012\uffae\013\uffae\015\uffae\017\uffae" +
    "\022\uffae\055\uffae\056\uffae\001\002\000\004\022\020\001" +
    "\002\000\006\047\uffcf\052\uffcf\001\002\000\004\022\020" +
    "\001\002\000\006\047\uffce\052\uffce\001\002\000\010\047" +
    "\uffcc\052\uffcc\053\307\001\002\000\004\054\310\001\002" +
    "\000\006\047\uffcb\052\uffcb\001\002\000\004\051\uffd8\001" +
    "\002\000\004\051\313\001\002\000\010\003\044\022\020" +
    "\052\uffd0\001\002\000\004\052\315\001\002\000\006\022" +
    "\uffdc\055\uffdc\001\002\000\006\022\020\055\317\001\002" +
    "\000\024\005\uffd7\007\uffd7\012\uffd7\013\uffd7\015\uffd7\017" +
    "\uffd7\022\uffd7\055\uffd7\056\uffd7\001\002\000\024\005\uffc9" +
    "\007\uffc9\012\uffc9\013\uffc9\015\uffc9\017\uffc9\022\uffc9\055" +
    "\uffc9\056\uffc9\001\002\000\024\005\073\007\065\012\067" +
    "\013\071\015\055\017\056\022\057\055\060\056\322\001" +
    "\002\000\010\016\uffd6\022\uffd6\056\uffd6\001\002\000\012" +
    "\006\uffe4\014\uffe4\022\uffe4\055\uffe4\001\002\000\004\055" +
    "\327\001\002\000\004\055\326\001\002\000\010\022\uffe0" +
    "\055\uffe0\056\uffe0\001\002\000\010\022\uffdf\055\uffdf\056" +
    "\uffdf\001\002\000\010\016\uffd9\022\uffd9\056\uffd9\001\002" +
    "\000\010\016\037\022\020\056\332\001\002\000\004\002" +
    "\000\001\002\000\004\053\350\001\002\000\004\022\342" +
    "\001\002\000\016\006\uffea\014\uffea\022\uffea\046\336\055" +
    "\uffea\056\uffea\001\002\000\014\006\uffeb\014\uffeb\022\uffeb" +
    "\055\uffeb\056\uffeb\001\002\000\014\006\uffec\014\uffec\022" +
    "\uffec\055\uffec\056\uffec\001\002\000\006\046\346\047\345" +
    "\001\002\000\006\046\uffe8\047\uffe8\001\002\000\010\046" +
    "\uffe7\047\uffe7\053\343\001\002\000\004\054\344\001\002" +
    "\000\006\046\uffe6\047\uffe6\001\002\000\004\022\342\001" +
    "\002\000\014\006\uffef\014\uffef\022\uffef\055\uffef\056\uffef" +
    "\001\002\000\006\046\uffe9\047\uffe9\001\002\000\004\054" +
    "\351\001\002\000\004\022\342\001\002\000\006\046\353" +
    "\047\345\001\002\000\014\006\uffed\014\uffed\022\uffed\055" +
    "\uffed\056\uffed\001\002\000\004\022\ufff9\001\002\000\004" +
    "\046\356\001\002\000\012\006\ufff7\014\ufff7\022\ufff7\055" +
    "\ufff7\001\002\000\004\022\361\001\002\000\006\046\371" +
    "\047\370\001\002\000\004\043\362\001\002\000\012\021" +
    "\364\023\367\024\363\025\365\001\002\000\006\046\ufff3" +
    "\047\ufff3\001\002\000\006\046\ufff4\047\ufff4\001\002\000" +
    "\006\046\ufff1\047\ufff1\001\002\000\006\046\ufff5\047\ufff5" +
    "\001\002\000\006\046\ufff2\047\ufff2\001\002\000\004\022" +
    "\372\001\002\000\012\006\ufff8\014\ufff8\022\ufff8\055\ufff8" +
    "\001\002\000\004\043\373\001\002\000\012\021\364\023" +
    "\367\024\363\025\365\001\002\000\006\046\ufff6\047\ufff6" +
    "\001\002\000\004\002\uffff\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\041\006\001\001\000\002\001\001\000\004\022\007" +
    "\001\001\000\014\003\012\023\011\025\014\044\013\052" +
    "\015\001\001\000\004\044\353\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\054\333\055\332\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\035\022\001\001\000\002\001\001\000" +
    "\004\056\024\001\001\000\002\001\001\000\004\026\025" +
    "\001\001\000\010\003\027\017\026\044\013\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\057\031\001\001" +
    "\000\004\004\032\001\001\000\006\005\035\044\034\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\062\040\001\001\000\002\001" +
    "\001\000\012\006\044\007\046\010\045\044\042\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\026\050\001\001" +
    "\000\006\003\027\044\013\001\001\000\004\063\052\001" +
    "\001\000\004\013\053\001\001\000\016\014\065\020\067" +
    "\021\060\037\062\042\061\043\063\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\013\265" +
    "\001\001\000\002\001\001\000\004\040\240\001\001\000" +
    "\024\030\225\031\162\032\157\042\077\043\063\045\105" +
    "\046\160\047\100\050\107\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\042\077\043\063\045\105\046\075\047" +
    "\100\050\107\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\042\077\043\063\045\105\047" +
    "\140\050\107\001\001\000\002\001\001\000\004\044\133" +
    "\001\001\000\002\001\001\000\004\015\122\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\034\116\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\042\077\043\063\045\105\046\111" +
    "\047\100\050\107\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\042\077\043\063\050\117\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\042\077" +
    "\043\063\045\123\050\107\001\001\000\004\034\116\001" +
    "\001\000\020\012\127\042\077\043\063\045\105\046\125" +
    "\047\100\050\107\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\016\042\077\043\063\045\105" +
    "\046\132\047\100\050\107\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\042\077\043\063" +
    "\045\105\046\135\047\100\050\107\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\015\122" +
    "\001\001\000\002\001\001\000\016\042\077\043\063\045" +
    "\105\046\143\047\100\050\107\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\030\163\031\162\032\157\042\077\043\063" +
    "\045\105\046\160\047\100\050\107\001\001\000\002\001" +
    "\001\000\004\033\211\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\014\171\020\172\021" +
    "\060\037\062\042\061\043\063\001\001\000\022\031\166" +
    "\032\157\042\077\043\063\045\105\046\160\047\100\050" +
    "\107\001\001\000\002\001\001\000\020\032\170\042\077" +
    "\043\063\045\105\046\160\047\100\050\107\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\020\175\021\174\037\062\042\061\043\063\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\014\177\020\200" +
    "\021\060\037\062\042\061\043\063\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\020\203\021\202\037\062" +
    "\042\061\043\063\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\042\077\043" +
    "\063\045\105\046\213\047\100\050\107\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\064\217\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\042\077\043\063" +
    "\045\105\046\222\047\100\050\107\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\020\230\021" +
    "\227\037\062\042\061\043\063\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\020\233\021\232\037\062\042" +
    "\061\043\063\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\011\254\012\256\042\077\043" +
    "\063\045\105\046\125\047\100\050\107\001\001\000\016" +
    "\042\077\043\063\045\105\046\246\047\100\050\107\001" +
    "\001\000\002\001\001\000\006\042\244\043\063\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\014\065\020\067\021\060\037\062\042" +
    "\061\043\063\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\042\273\043\063\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\007\302\044\042\001\001\000\002\001\001" +
    "\000\006\007\304\044\042\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\060\311\001\001\000\002\001\001\000\012\006\044\007" +
    "\046\010\313\044\042\001\001\000\002\001\001\000\004" +
    "\026\315\001\001\000\006\003\027\044\013\001\001\000" +
    "\004\061\317\001\001\000\004\013\320\001\001\000\016" +
    "\014\065\020\067\021\060\037\062\042\061\043\063\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\004\330\001\001\000\006\005\035\044\034\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\016\337\036" +
    "\340\001\001\000\004\027\336\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\036\346\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\016\351\036\340\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\053\356\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\024\357\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\051\365\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\051\373\001\001" +
    "\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 2;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init();	// U.S.
	
	Scope universe = Tab.currentScope();
	universe.addToLocals(new Obj(Obj.Type, "bool", CUP$MJParser$actions.boolType));
	universe.addToLocals(new Obj(Obj.Type, "string", CUP$MJParser$actions.stringType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;

    }



	boolean errorDetected = false;

	int globalChar = 0;
	int globalArray = 0;
	int functionDefinitions = 0;
	int innerClasses = 0;
	int blocks = 0;
	int mainFunctionCalls = 0;
	int objectCreation = 0;
	int methodInnerClass = 0;
	int declFieldInnerClass = 0;
	int extendedClasses = 0;
	int numOfChars = 0;
	
	int inClass = 0;
	int inMethod = 0;	
	int inClassMethod = 0;
	int inMain = 0;
	int inWhile = 0;
	boolean isMainVoid = false;
	boolean isMainOk = false;
	
	int formParamPos = 0;
	
	int brojZvezdica = 0;
	int printCallCount = 0;

	Logger log = Logger.getLogger(getClass());
   

     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna GRESKA", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("FATALNA GRESKA, KRAJ PARSIRANJA", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	public static final Struct boolType = new Struct(Struct.Bool);
    public static final Struct stringType = new Struct(Struct.Array,  new Struct(Struct.Char));
	
	Obj currentMethod = null;
	Struct currentClass = Tab.noType;
	boolean returnFound = false;
	Struct currVarType = Tab.noType;
	Struct currConstType = Tab.noType;
	int eqOrNeq = 0;
	boolean isPlus = false;
	boolean justVar = false;	
	boolean isArray = false;
	String currName;
	String currFuncName;
	boolean wasError = false;
	boolean hasParam = false;
	int mulopOp = 0;
	int constValue = 0;
	boolean indexError = false;
	
	LinkedList actParams = new LinkedList<Struct>();
	int actParamsCnt = 0;

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Mulop ::= MOD 
            {
              Object RESULT =null;
		 mulopOp = 3; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Mulop ::= DIV 
            {
              Object RESULT =null;
		 mulopOp = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Mulop ::= MUL 
            {
              Object RESULT =null;
		 mulopOp = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Addop ::= MINUS 
            {
              Object RESULT =null;
		 isPlus = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Addop ::= PLUS 
            {
              Object RESULT =null;
		 isPlus = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Relop ::= LE_EQU 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Relop ::= LESSER 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Relop ::= GR_EQU 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Relop ::= GREATER 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Relop ::= L_NEQUAL 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Relop ::= L_EQUAL 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 eqOrNeq = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Stars ::= MUL 
            {
              Object RESULT =null;
		
				parser.brojZvezdica++;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Stars",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Stars ::= Stars MUL 
            {
              Object RESULT =null;
		
				parser.brojZvezdica++;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Stars",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // DesignatorOperation ::= IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							
							Obj obj = Tab.find(name);
							if(obj == Tab.noObj)
								parser.report_error("GRESKA na liniji " + nameleft+ " : ime "+name+" nije deklarisano! ", null);
							else
								parser.report_info("Koristi se " + name + " na liniji " + nameleft, null);
							RESULT = obj;
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOperation",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // DesignatorOperation ::= DesignatorOperation LEFT_SQUARE_BRACKET error RIGHT_SQUARE_BRACKET 
            {
              Obj RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri indeksiranju niza u liniji " + lleft, null); indexError = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOperation",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // DesignatorOperation ::= DesignatorOperation LEFT_SQUARE_BRACKET NT$10 Expr RIGHT_SQUARE_BRACKET 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int zleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int zright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj z = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
						 	if(e.getKind()!=Struct.Int){
						 		parser.report_error("GRESKA na liniji: " + eleft + ": indeksiranje niza se mora vrsiti tipom int!", null);
						 	RESULT = Tab.noObj;
						 }
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOperation",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // NT$10 ::= 
            {
              Obj RESULT =null;
		int zleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int zright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj z = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

						 	isArray = true;
						 	 
						 	if(z.getType().getKind()!=Struct.Array)
						 		parser.report_error("GRESKA na liniji: " + lleft + ": promenljiva nije tipa niz!", null);
						 	Code.load(z);
						 	RESULT = new Obj(Obj.Elem, "", z.getType().getElemType());
						 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // DesignatorOperation ::= DesignatorOperation DOT IDENT 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOperation",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // Designator ::= DesignatorOperation 
            {
              Obj RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					RESULT = d;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // Factor ::= LEFT_BRACKET Expr RIGHT_BRACKET 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct d = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = d; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // Factor ::= NEW Type LEFT_SQUARE_BRACKET Expr RIGHT_SQUARE_BRACKET 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
		   		if(e.getKind()!=Struct.Int)
		   			parser.report_error("GRESKA na liniji " + eleft + ": Parametar izmedju uglastih zagrada mora biti tipa int.", null);
		   		parser.objectCreation++;
		   		
		   		 if(e == Tab.intType){ 
			       	 Code.put(Code.newarray);
			         if(t == Tab.charType) Code.put(0);
		         	 else Code.put(1);
		        	 parser.report_info("Kreiran niz elemenata", null);
		        	 RESULT = new Struct(Struct.Array, t);
		       	 }
				 else{
		        	 parser.report_error("GRESKA na liniji: " + tleft + ", mora int kao parametar!", null);
		        	 RESULT = Tab.noType;
		       }
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // Factor ::= NEW Type 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		   		if(t.getKind()!=Struct.Class)
		   			parser.report_error("GRESKA na liniji " + tleft + ": Tip mora da oznacava unutrasnju klasu.", null);
		   		parser.objectCreation++;
		   		RESULT = t;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Factor ::= BOOL_CONST 
            {
              Struct RESULT =null;
		
		   		RESULT = boolType;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // Factor ::= STR_CONST 
            {
              Struct RESULT =null;
		 RESULT = stringType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // Factor ::= CHAR_CONST 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character i = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		   		Obj c = Tab.insert(Obj.Con, "", Tab.charType);
		   		c.setAdr(i.charValue());
		   		Code.load(c);
		   		RESULT = Tab.charType;		   
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // Factor ::= NUMBER 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		   		Obj c = Tab.insert(Obj.Con, "", Tab.intType);
		   		c.setAdr(i.intValue());
		   		Code.load(c);
		   		RESULT = Tab.intType;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				Code.load(d);
		   		RESULT = d.getType();
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // Factor ::= Designator LEFT_BRACKET ActualParamList RIGHT_BRACKET 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
		   		if(parser.inMain == 1) parser.mainFunctionCalls++;
		   		
		   		if (Obj.Meth == func.getKind()){
		   			parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
		   			RESULT = func.getType();
		   			
		   			if(func.getType() == Tab.noType)
		   				parser.report_error("GRESKA na liniji " + funcleft + ": funkcija mora da ima povratnu vrednost!", null);
		   			else{
			   			int destAdr = func.getAdr() - Code.pc;
			   			Code.put(Code.call);
			   			Code.put2(destAdr);
		   			}
		   		}else{
		   			parser.report_error("GRESKA na liniji " + funcleft + ": poziva se funkcija koja ne postoji!", null);
		   			RESULT = Tab.noType;
		   			wasError = true;
		   		}
		   		
	   			if(!wasError){
		   			if(actParamsCnt!=func.getLevel()) parser.report_error("GRESKA na liniji " + funcleft + ": ne poklapaju se formalni i stvari parametri", null);
			   		else{
				   		Struct s = null;
				   		
				   		for (Obj obj : func.getLocalSymbols()){
				   				
			   				if(actParamsCnt>=0) s = (Struct) actParams.removeFirst();
			   				actParamsCnt--;
			   				
			   				if (obj.getType().getKind() != s.getKind()){
					       		parser.report_error("GRESKA na liniji " + funcleft + ": ne poklapaju se formalni i stvari parametri", null);
					       		break;
					       	}
		
						}
			   		}
		   		}
		   		else wasError = false;
		   
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // Factor ::= Designator LEFT_BRACKET RIGHT_BRACKET 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
		   		if(parser.inMain == 1) parser.mainFunctionCalls++;
		   
		   		if (Obj.Meth == func.getKind()){
		   			parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
		   			RESULT = func.getType();
		   			
		   			if(func.getType() == Tab.noType)
		   				parser.report_error("GRESKA na liniji " + funcleft + ": funkcija mora da ima povratnu vrednost!", null);
		   			else{
			   			int destAdr = func.getAdr() - Code.pc;
			   			Code.put(Code.call);
			   			Code.put2(destAdr);
		   			}
		   		}
				
				if(actParamsCnt>0) parser.report_error("GRESKA na liniji " + funcleft + ": ne poklapaju se formalni i stvari parametri", null);
				
		   		
		   
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Term ::= Factor 
            {
              Struct RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct f = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	RESULT = f;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // Term ::= Term Mulop Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct f = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	if(t!=null){
		 	if(t.getKind()!=Struct.Array && !(t.getKind()==Struct.Int && f.getKind()==Struct.Int))
		 		parser.report_error("GRESKA na liniji " + tleft + ": cinioci moraju biti tipa int.", null);
		 	else if(t.getKind()==Struct.Array && !(t.getElemType().getKind()==Struct.Int && f.getKind()==Struct.Int))
		 		parser.report_error("GRESKA na liniji " + tleft + ": cinioci moraju biti tipa int.", null);
			}
			
			if(mulopOp==1) Code.put(Code.mul);
			else if(mulopOp==2) Code.put(Code.div);
			else if(mulopOp==3) Code.put(Code.rem);
			
		 	RESULT = f;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ExprMore ::= Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprMore",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // ExprMore ::= ExprMore Addop Term 
            {
              Struct RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct te = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	if(te.compatibleWith(t) && (((te==Tab.intType || te==stringType) && isPlus==true) || te==Tab.intType)){
			 		RESULT = te;
			 	}
			 	else{
			 		parser.report_error("GRESKA na liniji " + teleft + ": nekompatibilni tipovi u izrazu.", null);
			 		RESULT = Tab.noType;
			 	}
			 	
			 	if(isPlus) Code.put(Code.add);
			 	else Code.put(Code.sub);
			 	
			 	justVar = false;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprMore",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // Expr ::= ExprMore 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	RESULT = t;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Expr ::= MINUS ExprMore 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	if(t.getKind()!=Struct.Int)
		 		parser.report_error("GRESKA na liniji " + tleft + ": Izraz uz minus moze biti samo tipa int.", null);
		 	RESULT = t;
		 	
			Code.put(Code.neg);
		 	
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // CondFact ::= Expr Relop Expr 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct e1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e2 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	if(!(e1.compatibleWith(e2)))
			 		parser.report_error("GRESKA na liniji " + e1left + ": Tipovi nisu kompatibilni.", null);
			 	if((e1.getKind()==Struct.Array || e1.getKind()==Struct.Class || e2.getKind()==Struct.Array || e2.getKind()==Struct.Class) && eqOrNeq==2)
			 		parser.report_error("GRESKA na liniji " + e1left + ": Uz tip niza ili klase mogu se koristiti samo == i !=.", null);
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // CondFact ::= Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // CondTerm ::= CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // Condition ::= CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // Condition ::= Condition OR CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ActualParamList ::= Expr 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						actParams.add(e);
						actParamsCnt++;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // ActualParamList ::= ActualParamList COMMA Expr 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						parser.log.debug("EXPR = " + e.getKind(), null);
						actParams.add(e);
						actParamsCnt++;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // ActualPars ::= 
            {
              Object RESULT =null;
		 hasParam = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // ActualPars ::= ActualParamList 
            {
              Object RESULT =null;
		 hasParam = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // Matched ::= LEFT_CURLY_BRACKET StatementList RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
		 parser.blocks++; isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // Matched ::= PRINT LEFT_BRACKET error RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske u listi parametara pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // Matched ::= PRINT error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // Matched ::= PRINT LEFT_BRACKET Expr COMMA NUMBER RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
				if(parser.inMain == 1) parser.mainFunctionCalls++;
				
				if(e!=stringType){
				if ((e.getKind() != Struct.Int) && (e.getKind() != Struct.Char) && (e.getKind() != Struct.Bool) && (e.getKind() != Struct.Array))
      				parser.report_error("Semanticka GRESKA na liniji " + eleft + ": Parametar u naredbi print nije dobar!" , null);
    			else if (e.getKind() == Struct.Array)
					if (isArray == false){
       					parser.report_error("Semanticka GRESKA na liniji " + eleft + ": Parametar u naredbi print nije dobar!" , null);
       					isArray = false;
     				}
     			}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // Matched ::= PRINT LEFT_BRACKET Expr RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				parser.log.debug("e.getKind() = " + e.getKind(), null);
				if(parser.inMain == 1) parser.mainFunctionCalls++;
     			
     			if(e.getKind()==Obj.Con) parser.report_error("Semanticka GRESKA na liniji " + eleft + ": parametar u naredbi print nije dobar!" , null);
     			else if(e!=stringType){
    			if ((e.getKind() != Struct.Int) && (e.getKind() != Struct.Char) && (e.getKind() != Struct.Bool) && (e.getKind() != Struct.Array))
      				parser.report_error("Semanticka GRESKA na liniji " + eleft + ": Parametar u naredbi print nije dobar!" , null);
    			else if (e.getKind() == Struct.Array)
					if (isArray == false){
       					parser.report_error("Semanticka GRESKA na liniji " + eleft + ": Parametar u naredbi print nije dobar!" , null);
       					isArray = false;
     				}
     			}
     			else
     				parser.report_info("Poziva se print na liniji " + eleft, null);
     			
     			if(e == Tab.intType){
	     			Code.loadConst(5);
	     			Code.put(Code.print);
     			}
     			if(e == Tab.charType){
     				Code.loadConst(1);
	     			Code.put(Code.bprint);     				
     			}
     			
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // Matched ::= READ LEFT_BRACKET error RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske u listi parametara pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // Matched ::= READ error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // Matched ::= READ LEFT_BRACKET Designator RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj e = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if(parser.inMain == 1) parser.mainFunctionCalls++;
				if(e.getKind()==Obj.Con) parser.report_error("Semanticka GRESKA na liniji " + eleft + ": parametar u naredbi read nije dobar!" , null);
				else if(e.getType()!=stringType){
				if ((e.getType().getKind() != Struct.Int) && (e.getType().getKind() != Struct.Char) && (e.getType().getKind() != Struct.Bool) && (e.getType().getKind() != Struct.Array))
      				parser.report_error("Semanticka GRESKA na liniji " + eleft + ": parametar u naredbi read nije dobar!" , null);
    			else if (e.getType().getKind() == Struct.Array)
					if (isArray == false){
       					parser.report_error("Semanticka GRESKA na liniji " + eleft + ": parametar u naredbi read nije dobar!" , null);
       					isArray = false;
     				}
     			}
     			else
     				parser.report_info("Poziva se read na liniji " + eleft, null);
     			
     				Code.put(Code.read);
           			Code.store(e);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Matched ::= RETURN SEMI_COMMA 
            {
              Object RESULT =null;
		 isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Matched ::= RETURN Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				returnFound = true;
				Struct currMethType = currentMethod.getType();
				if(!currMethType.compatibleWith(t)){
					parser.report_error("GRESKA na liniji " + tleft + ": tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				}
				isArray = false;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // Matched ::= BREAK SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if(parser.inWhile==0)
					parser.report_error("GRESKA na liniji " + lleft + ": Break se ne sme koristiti van while petlje.", null);
				isArray = false;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // Matched ::= WhileBegin error RIGHT_BRACKET Matched 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pogresnom logickom iskazu u liniji " + lleft, null); parser.inWhile = 0; isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // Matched ::= WhileBegin Condition RIGHT_BRACKET Matched 
            {
              Object RESULT =null;
		 parser.inWhile = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Matched ::= IF LEFT_BRACKET error RIGHT_BRACKET Matched ELSE Matched 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pogresnom logickom iskazu u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Matched ::= IF LEFT_BRACKET Condition RIGHT_BRACKET Matched ELSE Matched 
            {
              Object RESULT =null;
		 isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= Designator EQUAL Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				
				if(!indexError){
				if(!(dest.getKind()==Obj.Var || dest.getKind()==Obj.Elem || dest.getKind()==Obj.Fld))
					parser.report_error("GRESKA na liniji " + destleft + ": pogresna destinacija.", null);
				else if (!e.assignableTo(dest.getType()))
					parser.report_error("GRESKA na liniji " + destleft + ": nekompatibilni tipovi u dodeli vrednosti2.", null);
				else{
					Code.store(dest);
				}}
				else indexError = false;
				isArray = false;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= Designator EQUAL error RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske u listi parametara pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= Designator LEFT_BRACKET error RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske u listi parametara pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= Designator EQUAL error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri dodeli vrednosti u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= Designator LEFT_BRACKET error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pozivu funkcije u liniji " + lleft, null); isArray = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Matched ::= Designator LEFT_BRACKET ActualPars RIGHT_BRACKET SEMI_COMMA 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
				if(parser.inMain == 1) parser.mainFunctionCalls++;
				if (Obj.Meth == func.getKind()){
		   			parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
		   			RESULT = func.getType();
		   			
		   			int destAdr = func.getAdr() - Code.pc;
		   			Code.put(Code.call);
		   			Code.put2(destAdr);
		   			if(func.getType() != Tab.noType) Code.put(Code.pop);
		   			
		   			
		   		}else{
		   			parser.report_error("GRESKA na liniji " + funcleft + ": poziva se funkcija koja ne postoji!", null);
		   			RESULT = Tab.noType;
		   			wasError = true;
		   		}		   				   		

				if(!wasError && hasParam){
			   		if(actParamsCnt!=func.getLevel()) parser.report_error("GRESKA na liniji " + funcleft + ": ne poklapaju se formalni i stvari parametri", null);
			   		else{
				   		Struct s = null;
				   		
				   		for (Obj obj : func.getLocalSymbols()){
				   				
			   				if(actParamsCnt>=0) s = (Struct) actParams.removeFirst();
			   				actParamsCnt--;
			   				
			   				if (obj.getType().getKind() != s.getKind()){
					     		parser.report_error("GRESKA na liniji " + funcleft + ": ne poklapaju se formalni i stvari parametri", null);
					     		break;
					     	}
					
						}
			   		}
		   		}
		   		else wasError = false;
		   		
		   		int destAdr = func.getAdr() - Code.pc;
		   		Code.put(Code.call);
		   		Code.put2(destAdr);
		   		
		   		actParamsCnt = 0;
		   		isArray = false;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Matched ::= Designator DEC SEMI_COMMA 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if(!(dest.getKind()==Obj.Var || dest.getKind()==Obj.Elem || dest.getKind()==Obj.Fld))
					parser.report_error("GRESKA na liniji " + destleft + ": pogresna destinacija.", null);
				if(dest.getType()!=Tab.intType && dest.getKind()!=Obj.Elem)
					parser.report_error("GRESKA na liniji " + destleft + ": rezultat nije lvrednost.", null);
				
				
				if(dest.getKind()==Obj.Elem) Code.put(Code.dup2);
				
				Code.load(dest);
				Code.loadConst(1);
				Code.put(Code.sub);
				Code.store(dest);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Matched ::= Designator INC SEMI_COMMA 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if(!(dest.getKind()==Obj.Var || dest.getKind()==Obj.Fld || dest.getKind()==Obj.Elem))
					parser.report_error("GRESKA na liniji " + destleft + ": pogresna destinacija.", null);
				if(dest.getType()!=Tab.intType && dest.getKind()!=Obj.Elem)
					parser.report_error("GRESKA na liniji " + destleft + ": rezultat nije lvrednost.", null);
				
				if(dest.getKind()==Obj.Elem) Code.put(Code.dup2);
				
				Code.load(dest);
				Code.loadConst(1);
				Code.put(Code.add);
				Code.store(dest);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Matched ::= Designator Stars Designator SEMI_COMMA 
            {
              Object RESULT =null;
		int d1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int d1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d1 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int d2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int d2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj d2 = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				if(d1.getKind()!= Obj.Var && d2.getKind()!= Obj.Var && d1.getKind()!=Obj.Fld && d2.getKind()!=Obj.Fld)
					parser.report_error("Semanticka GRESKA na liniji " + d1left + ": neodgovarajuci parametri.", null);
				else {
					if (d1.getType() != Tab.intType || d2.getType() != Tab.intType)
						parser.report_error("Semanticka GRESKA na liniji " + d1left + ": parametri moraju biti polja.", null);
					else {
						int cnt = parser.brojZvezdica;
						parser.brojZvezdica = 0;
						Code.load(d1);
						Code.load(d2);
						Code.put(Code.add);
						Code.store(d2);
						for(int i=0; i<cnt;i++) Code.load(d1);
						for(int i=0; i<cnt-1;i++) Code.put(Code.mul);
						Code.store(d1);
					}
				}
				
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Unmatched ::= WhileBegin Condition RIGHT_BRACKET Unmatched 
            {
              Object RESULT =null;
		 parser.inWhile = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Unmatched ::= IF LEFT_BRACKET Condition RIGHT_BRACKET Matched ELSE Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Unmatched ::= WhileBegin error RIGHT_BRACKET Unmatched 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pogresnom logickom iskazu u liniji " + lleft, null); parser.inWhile = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Unmatched ::= IF LEFT_BRACKET error RIGHT_BRACKET Matched ELSE Unmatched 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pogresnom logickom iskazu u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Unmatched ::= IF LEFT_BRACKET error RIGHT_BRACKET Statement 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri pogresnom logickom iskazu u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // Unmatched ::= IF LEFT_BRACKET Condition RIGHT_BRACKET Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // WhileBegin ::= WHILE LEFT_BRACKET 
            {
              Object RESULT =null;
		 parser.inWhile = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("WhileBegin",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormalParamDecl ::= Type IDENT LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						Obj p = Tab.currentScope().findSymbol(varName);
						if(p==null){
							parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
							Obj r = Tab.insert(Obj.Var, varName, new Struct(Struct.Array, varType));
							r.setFpPos(parser.formParamPos);
							parser.formParamPos++;
						}else{
							parser.report_error("GRESKA na liniji " + varNameleft + ": Postoji promenljiva sa imenom " + varName + ".", null);
					}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FormalParamDecl ::= Type IDENT 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
						Obj p = Tab.currentScope().findSymbol(varName);
						if(p==null){
							parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
							Obj r = Tab.insert(Obj.Var, varName, varType);
							r.setFpPos(parser.formParamPos);

							parser.formParamPos++;
						}else{
							parser.report_error("GRESKA na liniji " + varNameleft + ": Postoji promenljiva sa imenom " + varName + ".", null);
					}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // FormalParamList ::= FormalParamDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // FormalParamList ::= error COMMA FormalParamDecl 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri definisanju formalnih parametara funkcije u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // FormalParamList ::= FormalParamList COMMA FormalParamDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // FormPars ::= 
            {
              Object RESULT =null;
		
				if(parser.isMainVoid && parser.inMain==1) parser.isMainOk = true;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // FormPars ::= error 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od greske pri definisanju formalnih parametara funkcije u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // FormPars ::= FormalParamList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // MethodDecl ::= VOID IDENT NT$8 LEFT_BRACKET FormPars RIGHT_BRACKET VarDeclListList LEFT_CURLY_BRACKET NT$9 StatementList RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		
			   		if(parser.inMethod == 1) parser.functionDefinitions++;
			   		if(parser.inClass == 1) parser.methodInnerClass++;
			   		if(parser.inMain == 1) parser.inMain = 0;
			   		
			   		Code.put(Code.exit);
			   		Code.put(Code.return_);
			   		
			   		currentMethod.setLevel(parser.formParamPos-1);
			   		parser.formParamPos = 1;
			   		
			   		actParams.clear();
			   		
			   		Tab.chainLocalSymbols(currentMethod);
			   		Tab.closeScope();
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // NT$9 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
			   		
			   		currentMethod.setAdr(Code.pc);
			   		if(methName.equals("main")){
			   				Code.mainPc = currentMethod.getAdr();
			   		}
			   		
		   			Code.put(Code.enter);
		   			Code.put(currentMethod.getLevel());
		   			Code.put(Tab.currentScope().getnVars());
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$8 ::= 
            {
              Object RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				   	if(methName.equals("main")) { parser.inMain = 1; parser.isMainVoid = true; }
			   		Obj c = Tab.find(methName);
			   		if(c==Tab.noObj || c.getKind()!=Obj.Meth){
			   			currentMethod = Tab.insert(Obj.Meth, methName, Tab.noType);
			   			parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
			   			parser.formParamPos = 1;
			   		}
			   		else{
			   			currentMethod = Tab.noObj;
			   			parser.report_error("GRESKA na liniji " + methNameleft + ": Metoda/funkcija sa imenom " + methName + " vec postoji.", null);
			   		}
			   		Tab.openScope();
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // MethodDecl ::= Type IDENT NT$6 LEFT_BRACKET FormPars RIGHT_BRACKET VarDeclListList LEFT_CURLY_BRACKET NT$7 StatementList RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		
			   		if(parser.inMethod == 1) parser.functionDefinitions++;
			   		if(parser.inClass == 1) parser.methodInnerClass++;
			   		if(parser.inMain == 1) parser.inMain = 0;
			   		
			   		if(!returnFound && retType != Tab.noType){
			   			parser.report_error("GRESKA na liniji " + methNameleft + ": funkcija " + methName + " nema return iskaz.", null);
			   		}
			   		
			   		
			   		Code.put(Code.exit);
			   		Code.put(Code.return_);
			   		
			   		
			   		returnFound=false;
			   		
			   		currentMethod.setLevel(parser.formParamPos-1);
			   		parser.formParamPos = 1;
			   		
			   		actParams.clear();			   		
			   		
			   		Tab.chainLocalSymbols(currentMethod);
			   		Tab.closeScope();
			   		
			   		
			   		
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
   
			   			currentMethod.setAdr(Code.pc);
			   			if(methName.equals("main")){
			   				Code.mainPc = currentMethod.getAdr();
			   			}
			   			
			   			Code.put(Code.enter);
			   			Code.put(currentMethod.getLevel());
			   			Code.put(Tab.currentScope().getnVars());
			   			
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$6 ::= 
            {
              Object RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			   		if(methName.equals("main")){
			   			parser.inMain = 1;
			   			parser.report_error("GRESKA:Main ne moze imati povratnu vrednost!", null);
			   		}
			   		
			   		Obj c = Tab.find(methName);
			   		if(c==Tab.noObj || c.getKind()!=Obj.Meth){
			   			currentMethod = Tab.insert(Obj.Meth, methName, retType);
			   			parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
			   			parser.formParamPos = 1;
			   		}
			   		else{
			   			currentMethod = Tab.noObj;
			   			parser.report_error("GRESKA na liniji " + methNameleft + ": Metoda/funkcija sa imenom " + methName + " vec postoji.", null);
			   		}
			   		Tab.openScope();
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	Obj typeNode = Tab.find(typeName);
		 	if (typeNode == Tab.noObj){
		 		parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", null);
		 		RESULT = Tab.noType;
		 	}
		 	else{
		 		if (Obj.Type == typeNode.getKind()){
		 			RESULT = typeNode.getType();
		 		}
		 		else{
		 			parser.report_error("GRESKA na liniji" + typeNameleft + ": Ime " + typeName + " ne predstavlja tip", null);
		 			RESULT = Tab.noType;
		 		}
		 	}
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // VarDeclListList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclListList",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // VarDeclListList ::= VarDeclListList VarDeclList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclListList",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // OptionalType ::= LEFT_CURLY_BRACKET 
            {
              Object RESULT =null;
		 parser.inClass = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptionalType",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // OptionalType ::= EXTENDS error LEFT_CURLY_BRACKET 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.inClass = 1; parser.log.debug("Oporavak od greske pri prosirenju natklase u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptionalType",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // OptionalType ::= EXTENDS IDENT LEFT_CURLY_BRACKET 
            {
              Object RESULT =null;
		int extTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int extTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String extType = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				 	Obj p = Tab.find(extType);
				 	if(!(p.getType().getKind()==Struct.Class) || p==Tab.noObj){
				 		parser.report_error("GRESKA na liniji " + extTypeleft + ": Ne postoji klasa " + p.getName() + ".", null);
				 	}
				 	parser.inClass = 1; parser.extendedClasses++;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptionalType",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // OptionalMeth ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptionalMeth",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // OptionalMeth ::= LEFT_CURLY_BRACKET NT$5 MethodDeclList RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptionalMeth",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.inClassMethod = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ClassDecl ::= CLASS IDENT OptionalType NT$4 VarDeclListList OptionalMeth RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
			  	parser.innerClasses++; parser.inClass = 0; parser.inClassMethod = 0;
			  	parser.report_info("Deklarisana klasa " + className + " na liniji " + classNameleft, null);
				Tab.chainLocalSymbols(currentClass);
     			Tab.closeScope();
     			currentClass = Tab.nullType;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // NT$4 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

			  	Obj p = Tab.find(className);
			  	if(p==Tab.noObj)
			  		currentClass = (Tab.insert(Obj.Type, className, Tab.nullType)).getType();
			  	else
			  		parser.report_error("GRESKA na liniji " + classNameleft + ": klasa sa imenom " + className + " je vec definisana.", null);
			  	Tab.openScope();
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VarPart ::= IDENT LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
				Obj p = Tab.currentScope().findSymbol(varName);
				if(p==null){
					if(currVarType.getKind()==Struct.Char) parser.numOfChars++;
					parser.report_info("Deklarisan niz promenljivih " + varName + " na liniji " + varNameleft, null);
					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, currVarType));
				}else{
					parser.report_error("GRESKA na liniji " + varNameleft + ": Promenljiva " + varName + " je vec deklarisana.", null);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarPart",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VarPart ::= IDENT 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				Obj p = Tab.currentScope().findSymbol(varName);
				if(currVarType.getKind()==Struct.Char) parser.numOfChars++;
				if(p==null){
					parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
					if(parser.inClass==1) Tab.insert(Obj.Fld, varName, currVarType);
					else Tab.insert(Obj.Var, varName, currVarType);
				}else{
					parser.report_error("GRESKA na liniji " + varNameleft + ": Promenljiva " + varName + " je vec deklarisana.", null);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarPart",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // MoreVar ::= VarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MoreVar",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // MoreVar ::= MoreVar COMMA VarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MoreVar",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // Choice ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Choice",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Choice ::= SEMI_COMMA 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Choice",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // VarDeclList ::= Type error Choice 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 if(parser.inMethod == 1 || parser.inClassMethod == 1) parser.log.debug("Oporavak od greske pri definisanju lokalne promenljive u liniji " + lleft, null);
				   else if(parser.inClass == 1)  parser.log.debug("Oporavak od greske pri definisanju polja unutrasnje klase u liniji " + lleft, null);
				   else parser.log.debug("Oporavak od greske pri definisanju globalne promenljive u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // VarDeclList ::= Type NT$3 LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET MoreVar SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // NT$3 ::= 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					if(parser.inMethod == 0 && parser.inClass == 0) parser.globalArray++;
			    	if(parser.inClass == 1 && parser.inClassMethod == 0) parser.declFieldInnerClass++;
			    	currVarType = varType;
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDeclList ::= Type NT$2 MoreVar SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // NT$2 ::= 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					if(parser.inClass == 1 && parser.inClassMethod == 0) parser.declFieldInnerClass++;
					currVarType = varType;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // AssignableConst ::= STR_CONST 
            {
              Struct RESULT =null;
		 RESULT = stringType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignableConst",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // AssignableConst ::= CHAR_CONST 
            {
              Struct RESULT =null;
		 RESULT = Tab.charType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignableConst",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // AssignableConst ::= BOOL_CONST 
            {
              Struct RESULT =null;
		 RESULT = boolType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignableConst",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // AssignableConst ::= NUMBER 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.intType; constValue = i.intValue(); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AssignableConst",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // MoreConst ::= IDENT EQUAL AssignableConst 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int checkTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int checkTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct checkType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 if(currConstType!=checkType)
			  		parser.report_error("GRESKA na liniji " + checkTypeleft + ": Dodela pogresnog tipa konstanti " + varName, null);
			 	else{
				Obj p = Tab.currentScope().findSymbol(varName);
				if(p==null){
					parser.report_info("Definisana konstanta " + varName + " na liniji " + varNameleft, null);
					Obj r = Tab.insert(Obj.Con, varName, currConstType);
					r.setAdr(constValue);
				}else{
					parser.report_error("GRESKA na liniji " + varNameleft + ": Promenljiva/konstanta " + varName + " je vec deklarisana.", null);
				}
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MoreConst",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // MoreConst ::= MoreConst COMMA IDENT EQUAL AssignableConst 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int checkTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int checkTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct checkType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			  	if(currConstType!=checkType)
			  		parser.report_error("GRESKA na liniji " + checkTypeleft + ": Dodela pogresnog tipa konstanti " + varName, null);
			  	else{
				Obj p = Tab.currentScope().findSymbol(varName);
				if(p==null){
					parser.report_info("Definisana konstanta " + varName + " na liniji " + varNameleft, null);
					Obj r = Tab.insert(Obj.Con, varName, currConstType);
					r.setAdr(constValue);
				}else{
					parser.report_error("GRESKA na liniji " + varNameleft + ": Promenljiva/konstanta " + varName + " je vec deklarisana.", null);
				}
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MoreConst",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ConstDeclList ::= CONST error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.log.debug("Oporavak od gre`ske pri dodeli vrednosti u liniji " + lleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ConstDeclList ::= CONST Type NT$1 MoreConst SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int constTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct constType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // NT$1 ::= 
            {
              Object RESULT =null;
		int constTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct constType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 currConstType = constType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ConstVarClass ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstVarClass",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // ConstVarClass ::= ConstVarClass ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstVarClass",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // ConstVarClass ::= ConstVarClass VarDeclList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstVarClass",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // ConstVarClass ::= ConstVarClass ConstDeclList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstVarClass",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ProgName ::= IDENT 
            {
              Obj RESULT =null;
		int pNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int pNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String pName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
			 	Tab.openScope();
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgName",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Program ::= PROG ProgName ConstVarClass NT$0 LEFT_CURLY_BRACKET MethodDeclList RIGHT_CURLY_BRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
				Code.dataSize = Tab.currentScope().getnVars();
				Tab.chainLocalSymbols(p);
				Tab.closeScope();
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // NT$0 ::= 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 parser.inMethod = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

